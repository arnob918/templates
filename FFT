template<typename float_t>
struct mycomplex {
	float_t x, y;

	mycomplex<float_t>(float_t _x = 0, float_t _y = 0) : x(_x), y(_y) {}

	float_t real() const { return x; }
	float_t imag() const { return y; }

	void real(float_t _x) { x = _x; }
	void imag(float_t _y) { y = _y; }

	mycomplex<float_t>& operator+=(const mycomplex<float_t> &other) { x += other.x; y += other.y; return *this; }
	mycomplex<float_t>& operator-=(const mycomplex<float_t> &other) { x -= other.x; y -= other.y; return *this; }

	mycomplex<float_t> operator+(const mycomplex<float_t> &other) const { return mycomplex<float_t>(*this) += other; }
	mycomplex<float_t> operator-(const mycomplex<float_t> &other) const { return mycomplex<float_t>(*this) -= other; }

	mycomplex<float_t> operator*(const mycomplex<float_t> &other) const {
		return {x * other.x - y * other.y, x * other.y + other.x * y};
	}

	mycomplex<float_t> operator*(float_t mult) const {
		return {x * mult, y * mult};
	}

	friend mycomplex<float_t> conj(const mycomplex<float_t> &c) {
		return {c.x, -c.y};
	}

	friend ostream& operator<<(ostream &stream, const mycomplex<float_t> &c) {
		return stream << '(' << c.x << ", " << c.y << ')';
	}
};
using cd = mycomplex<double>;

void fft(vector<cd> & a, bool invert) {
    int n = a.size();

    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;

        if (i < j)
            swap(a[i], a[j]);
    }

    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w = w*wlen;
            }
        }
    }

    if (invert) {
        for (cd & x : a){
            double z = n;
            z=1/z;
            x = x*z;
        }
           // x /= n;
    }
}

void multiply (const vector<bool> & a, const vector<bool> & b, vector<bool> & res) {//change all the bool to your type needed
    vector<cd> fa (a.begin(), a.end()),  fb (b.begin(), b.end());
    size_t n = 1;
    while (n < max (a.size(), b.size()))  n <<= 1;
    n <<= 1;
    fa.resize (n),  fb.resize (n);

    fft (fa, false),  fft (fb, false);
    for (size_t i=0; i<n; ++i)
        fa[i] =fa[i] * fb[i];
    fft (fa, true);

    res.resize (n);
    for (size_t i=0; i<n; ++i)
        res[i] = round(fa[i].real());
}

void pow(const vector<bool> &a, vector<bool> &res, long long int k){
	vector<bool> po=a;
	res.resize(1);
	res[0] = 1;
	while(k){
		if(k&1){
			multiply(po, res, res);
		}
		multiply(po, po, po);
		k/=2;
	}
}
